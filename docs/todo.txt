----

TESTING PLAN

update:
    all

easy:
    Solar_Filter
    
----

DOCUMENTATION PLAN

update:
    all
    
easy:
    Solar_Filter
    Solar_Form_Load_Table
    
average:
    Solar_User_Auth
    Solar_User_Role

difficult:
    Solar_User
    Solar_Sql
    Solar_Sql_Table
    Solar_Sql_Select

Solar_Template is Savant3, use Savant3 docs.


----

NEW CLASSES

Create an event dispatcher as a universal observer and notifier?

Do we need a Solar_Template or Solar_View proper?  (Ick.)

Solar_User_Priv for class/action/op privileges by user and role

Add Solar_User_Message for flash-style messaging?  Need flashes, anyway.


----

NEW MODELS & APPS

Solar_Model_Bugs

Solar_App_Bugs

Solar_Model_Comments

    Need a 'remember me' function

    Need to separate Solar_Model_Comments_Rules into a standalone
    content-filtering class ... or add a file-based plugin mechanism? 
    or both?  Text_Bayes?  Text_Filter?

Solar_Model_Members
    id
    created_on
    updated_on
    confirmed_on
    confirm_code
    handle
    passwd
    public
    email
    uri

Solar_App_Member
    roster
    register
    passwd
    forgot
    profile
    
Solar_Model_Privs
    id
    created_on
    updated_on
    allow
    type
    name
    class
    action
    op
    
Solar_App_Priv

Solar_Model_Comments

----

Bookmarks

In list headings, make 'user' clickable, make individual tags clickable

Search by URL, title, description

Change all instances of tag X to tag Z


----

Solar_Model_Comments



----

Text classes:

Text/Bayes.php (tracks bayes filtering) -- would this be Solar_Model_Bayes?
Text/Csv.php (parse/build CSV/TSV/etc blocks)
Text/Diff.php (get a diff on text)
Text/Filter.php (modifies text to match a filter)
Text/Markup.php (for wiki, bbcode, textile, markdown, email, etc)
    - a way to do simple common stuff, then a way to do more complex stuff
    - common regexes for URI, email, wikilink, freelink, interwiki
    - common regexes for inline bold, italic, tt/code, etc

----

Preferences

sc_pref (whole application AND/OR user prefs, *must* support arrays?)
    id       unique id
    user_id  '_SOLAR_APP' for application prefs)
    app      name of the app (64)
    elem     name of the pref element (64)
    value    the value of the pref element (255) (or CLOB?)
    
REALLY need to work out the preferences thing.

Need to know if it's single-value keys only, or if multi-values per key are allowed.
(Multi shoud be allowed).

The return array should be like the Solar::config() arrays.

SO, e.g, Solar_App_Talk prefs would look like:

    spam => array(word, word, word, word)
    autoFlag => 'spam'
    
And then you need a prefs object to tell you what keys go with what labels, etc.

That by itself is a project.

So for now, to get it off the ground, no prefs at all, just Solar::$config values.


----

Text_Markup

Text/
    Markup.php
    Markup/
        Parse.php
        Parse/
            Bbcode.php -- extends Text_Markup_Parse
            Bbcode/
                Url.php -- extends Text_Markup_Parse_Rule
            DokuWiki.php
            DokuWiki/
            Email.php
            Email/
            Markdown.php
            Markdown/
            MediaWiki.php
            MediaWiki/
            PearWiki.php
            PearWiki/
            Rule.php -- base for parse-rule objects, not an extension of Markup_Parse
            SolarWiki.php
            SolarWiki/
            Textile.php
            Textile/
        Render.php
        Render/
            Email.php -- extends Text_Markup_Render
            Email/
                Url.php -- extends Text_Markup_Render_Rule
            Plain.php
            Plain/
            Rule.php -- base for render-rule objects, not an extension of Markup_Render
            Xhtml.php
            Xhtml/
    
    
Usage:

// create a markup object
$markup = Solar::object('Solar_Text_Markup');

// set up the parsing by class name; default is SolarWiki
$options = array(...);
$markup->setParse('Solar_Text_Markup_Parse_Bbcode', $options);

/*
// alternative: set up the parsing by object instance
$parse = Solar::object('Solar_Text_Markup_Parse_Bbcode', $options);
$markup->setParse($parse);
*/

// set up the rendering by class name; default is Xhtml
$options = array(...);
$markup->setRender('Solar_Text_Markup_Render_Xhtml', $options);

/*
// alternative: set up the rendering by object instance
$render = Solar::object('Solar_Text_Markup_Render_Xhtml', $options);
$markup->setParse($render);
*/

// transform the source text
$output = $markup->transform($source);


When instantiating, have the parse/render object instantiate the rule objects
immediately? That way you could address their configs directly, if needed ...

URLs:
    http://example.com
    [http://example.com] (rendered as superscript?)
    [http://example.com |] (drops the scheme)
    [http://example.com | rendered as this]

Wiki (option to render with spaces)
    PageName
    PageName#anchor
    [PageName#anchor] ???
    [PageName#anchor |] ???
    [PageName#anchor | rendered as this]
    
Free:
    [free page name]
    [free page name#anchor]
    [free page name#anchor | rendered as this]

Inter:
    Interwiki:PageName
    Interwiki:PageName#anchor
    [Interwiki:PageName#anchor | rendered as this]
    [Interwiki:free page name]
    [Interwiki:free page name#anchor]
    [Interwiki:free page name#anchor |] (drops the interwiki name)
    [Interwiki:free page name#anchor | rendered as this]
    Use of double-colons also allowed?
    
Default Interwikis:
    Amazon:
    Google:
    Imdb:
    IMDB:
    Isbn:
    ISBN:
    Issn:
    ISSN:
    Php:
    PHP:
