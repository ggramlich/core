CENTRAL CONTENT MODEL

A node might have:
	one page ("main")
	a series of comments
	a series of files


A area has multiple nodes
A node has multiple parts
A part has multiple edits (this is for "history" and "archive" purposes)

users (doubles as user prefs)
	user_handle      -- varchar(32) -- handle
	user_passwd      -- varchar(32) -- md5 hashed password
	user_email       -- 
	user_n_title     -- 
	user_n_first     -- 
	user_n_middle    -- 
	user_n_last      -- 
	user_n_suffix    -- 
	user_tel         -- 
	user_adr_pob     -- 
	user_adr_ext     -- 
	user_adr_street  -- 
	user_adr_city    -- 
	user_adr_region  -- 
	user_adr_code    -- 
	user_adr_country -- 
	user_adr_locale  -- 
	
areas
	area_name        -- varchar(127) -- unique name for this area
	area_subj        -- short description of the area (tagline)
	area_user_handle -- the "owner" of this area
	area_prefs       -- serialized array of area preferences

nodes (indexed on node_name + area_name)
	node_name        -- varchar(127) -- unique name for this node for the area
	node_area_name   -- varchar(127) -- which area this node belongs to
	node_tags        -- tags for this node
	node_user_handle -- the "owner" of this node
	node_prefs       -- serialized array of preferences for this node
	
parts
	part_id          -- integer -- unique ID for this part
	part_area_name   -- is a part of this area
	part_node_name   -- is a part of this node
	part_type        -- arbitrary part type (wiki, blog, news, comment, forum, etc)
	part_prefs       -- serialized array of prefs for this part
	part_locale      -- the locale code for this part
	part_edit_id     -- the most-current edit ID for this part
	part_user_handle -- the "owner" of this part
	
edits
	edit_id          -- bigint -- unique ID for this edit
	edit_part_id     -- which part this edit belongs to
	edit_ts          -- timestamp on the edit
	edit_ip_addr     -- IP address of the editor
	edit_user_handle -- the username of the editor
	edit_flag        -- arbitrary flag on this edit (moderate, spam, disable, etc)
	edit_mime        -- MIME type (text/plain)
	edit_subj        -- subject, title, filename, uri, etc
	edit_summ        -- short summary
	edit_body        -- the actual content
	edit_prefs       -- serialized array of prefs for this edit
	
tags
	tag_area_name    -- the area to which this tag applies
	tag_node_name    -- the node in the area
	tag_name         -- the tag itself

hits
	hit_id           -- unique ID for the hit
	hit_area_name    -- area
	hit_node_name    -- node
	hit_ts           -- timestamp in Y-m-dTH:i:s format
	hit_u            -- timestamp in Unix epoch seconds
	hit_y            -- year
	hit_m            -- month
	hit_d            -- day
	hit_h            -- hour
	hit_i            -- minute
	hit_s            -- second
	hit_w            -- day-of-week
	hit_session      -- session number of the visitor
	hit_ip_addr      -- ip address of the visitor
	hit_referer      -- the full referer string
	hit_referer_host -- referer host
	hit_referer_qstr -- referer query string
	
privs
	priv_id          -- unique ID for this privilege
	priv_seq         -- arbitrary sequence number
	priv_flag        -- 0/1, deny or allow
	priv_type        -- user-based or role-based priv?
	priv_name        -- name of the user or role the priv applies to 
	priv_ctrl        -- name of the control (comment_ins, comment_del, comment_upd, page_ins, etc)
	priv_area_name   -- control on this area
	priv_node_name   -- control on this node in the area

search
	search_id        -- 
	search_part_id   -- 
	search_word      -- 
	search_rank      --
	
----

Selections:

	$content->areas->fetchList()
	$content->areas->fetchItem($area_name)
	
	$content->nodes->fetchList($area_name)
	$content->nodes->fetchItem($area_name, $node_name)
	
	$content->parts->fetchList($area_name, $node_name, $where, $order)
	$content->parts->fetchItem($part_id)
	
	$content->edits->fetchList($area_name, $node_name, $part_id)
	$content->edits->fetchItem($edit_id)
	
	
----

Issue Tracking System

	a standard issues table
	use the universal comment system driven by the content system
	what area and node do we use in these cases?
	area_name: Solar_App_Issues
	node_name: 12345
	connect first to the bugs table, then grab comments from general content

----

Bookmark System fits entirely within content system

	area_name -- pmjones_bookmarks
	node_name -- wiki-fied URI title
	part_type -- bookmark
	edit_mime -- text/plain
	edit_subj -- URI for the link URI
	edit_summ -- title for the link
	edit_body -- description of the link

Selecting bookmarks:

SELECT *
FROM edits
WHERE
	areas.area_name == 'pmjones_bookmarks' AND
	parts.part_type == 'bookmark' AND
	parts.user_handle == 'pmjones' AND
	
...???...




==== ==== ==== ==== 

OLD MODEL

Content storage (really for anything ... think "wiki=content" and "page=node")

sc_content_areas (no notification, use RSS feeds)
	area -- unique name of the area (short form)
	subj -- title for the area (long form)
	summ -- short sentence or descriptive phrase
	
sc_content_nodes
	id       -- unique sequential ID that stays the same across all edits
	area     -- area name
	node     -- node name
	tags     -- tags for the node (no history of these)
	rel      -- related table for added info
	rel_id   -- the id in the related table
	comments -- 0/1, whether comments are allowed or not

sc_content_parts
	id       -- unique sequential ID
	node_name-- from sc_content_nodes.id
	locale   -- the language of the edit (e.g., en_US)
	type     -- the content type: 
	current  -- 0/1, is the most-current version for its locale and type
	draft    -- 0/1, in draft mode (which means edits are in-place, no history is captured)
	ts       -- timestamp of the edit
	user_id  -- user ID of the editor
	ip_addr  -- IP address of the editor
	mime     -- the mime type, which indicates a markup type (text/x-solar-wiki, text/x-solar-email, etc)
	subj     -- the subject line: title, filename, etc
	summ     -- summary text
	body     -- main body text

sc_content_links
	id       -- unique sequential ID
	locale   -- the locale of the linking
	src_area -- source area
	src_node -- source node
	tgt_area -- target area
	tgt_node -- target node


sc_content_pings -- who we have pinged for trackback


To get most-recent content node:

	SELECT sc_content_nodes.*, sc_content_edits.*
	FROM sc_content_nodes
	JOIN sc_content_edits ON sc_content_nodes.id = sc_content_edits.node_id
	WHERE
		sc_content_nodes.area = :area AND
		sc_content_nodes.node = :node AND
		sc_content_edits.current = '1'
	ORDER BY id DESC
	LIMIT (count=1 offset=0)

When inserting a new node:

	first: INSERT INTO sc_content_edits (..., current) VALUES (..., '1');
	then:  UPDATE sc_content_edits SET current = 0 WHERE ... AND ts < $ts;
	


----

Blogging

sc_blog_drafts
	id
	area
	node
	ts
	user_id
	comments -- whether comments will be allowed or not
	tags     -- space-sep list, /[a-z0-9_]+/i) ... get dumped to sc_content_tags later
	title
	body

For bloglinks, use the Solar_App_Bookmarks info in a theme

Need a default node name (WebLog) and suffix (timestamp created).  You
can change the title to anything else, of course.

To get top 10 blog entries ...

	SELECT *
	FROM sc_content_nodes
	WHERE
		current = '1' AND
		node >= 'WebLog_0001-01-01T00:00:00' AND
		node <= 'WebLog_9999-12-31T23:59:59' AND 
		area = :area
	ORDER BY node DESC
	LIMIT (count=10 offset=0)

Could we concatenate the combination of the title, categories, and post body
for the entire node, and then cache that?  it would be faster than to cache
each individual entry and re-get each one every time, right?

Or would it be better to designate an entire area as a blog? Then you get "real" node 
names, not "WebLog_...".


----

Page attachments

sc_file
	id
	name
	title
	descr
	mime
	data

sc_content_file
	id
	area
	node
	nick (nickname for the file as related to this node)
	file_id


----

Searching (only on current)

sc_content_index
	node_id
	word
	times
	
When you save, it converts to plain-text, tokenizes into words ...
Then takes a word-count on each and saves in the content index for the node_id.
