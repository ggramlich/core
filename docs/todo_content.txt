CENTRAL CONTENT MODEL

A node might have:
	one page ("main")
	a series of comments
	a series of files


A area has multiple nodes
A node has multiple parts
A part has multiple edits (this is for "history" and "archive" purposes)

Selections:

	$content->areas->fetchList()
	$content->areas->fetchItem($area_name)
	
	$content->nodes->fetchList($area_name)
	$content->nodes->fetchItem($area_name, $node_name)
	
	$content->parts->fetchList($area_name, $node_name, $where, $order)
	$content->parts->fetchItem($part_id)
	
	$content->edits->fetchList($area_name, $node_name, $part_id)
	$content->edits->fetchItem($edit_id)
	
	
----

Issue Tracking System

	a standard issues table
	use the universal comment system driven by the content system
	what area and node do we use in these cases?
	area_name: Solar_App_Issues
	node_name: 12345
	connect first to the bugs table, then grab comments from general content

----

Bookmark System fits entirely within content system

	area_name -- pmjones_bookmarks
	node_name -- wiki-fied URI title
	part_type -- bookmark
	edit_mime -- text/plain
	edit_subj -- URI for the link URI
	edit_summ -- title for the link
	edit_body -- description of the link

Selecting bookmarks:

SELECT *
FROM edits
WHERE
	areas.area_name == 'pmjones_bookmarks' AND
	parts.part_type == 'bookmark' AND
	parts.user_handle == 'pmjones' AND
	
...???...




==== ==== ==== ==== 

OLD MODEL

Content storage (really for anything ... think "wiki=content" and "page=node")

sc_content_areas (no notification, use RSS feeds)
	area -- unique name of the area (short form)
	subj -- title for the area (long form)
	summ -- short sentence or descriptive phrase
	
sc_content_nodes
	id       -- unique sequential ID that stays the same across all edits
	area     -- area name
	node     -- node name
	tags     -- tags for the node (no history of these)
	rel      -- related table for added info
	rel_id   -- the id in the related table
	comments -- 0/1, whether comments are allowed or not

sc_content_parts
	id       -- unique sequential ID
	node_name-- from sc_content_nodes.id
	locale   -- the language of the edit (e.g., en_US)
	type     -- the content type: 
	current  -- 0/1, is the most-current version for its locale and type
	draft    -- 0/1, in draft mode (which means edits are in-place, no history is captured)
	ts       -- timestamp of the edit
	user_id  -- user ID of the editor
	ip_addr  -- IP address of the editor
	mime     -- the mime type, which indicates a markup type (text/x-solar-wiki, text/x-solar-email, etc)
	subj     -- the subject line: title, filename, etc
	summ     -- summary text
	body     -- main body text

sc_content_links
	id       -- unique sequential ID
	locale   -- the locale of the linking
	src_area -- source area
	src_node -- source node
	tgt_area -- target area
	tgt_node -- target node


sc_content_pings -- who we have pinged for trackback


To get most-recent content node:

	SELECT sc_content_nodes.*, sc_content_edits.*
	FROM sc_content_nodes
	JOIN sc_content_edits ON sc_content_nodes.id = sc_content_edits.node_id
	WHERE
		sc_content_nodes.area = :area AND
		sc_content_nodes.node = :node AND
		sc_content_edits.current = '1'
	ORDER BY id DESC
	LIMIT (count=1 offset=0)

When inserting a new node:

	first: INSERT INTO sc_content_edits (..., current) VALUES (..., '1');
	then:  UPDATE sc_content_edits SET current = 0 WHERE ... AND ts < $ts;
	


----

Blogging

sc_blog_drafts
	id
	area
	node
	ts
	user_id
	comments -- whether comments will be allowed or not
	tags     -- space-sep list, /[a-z0-9_]+/i) ... get dumped to sc_content_tags later
	title
	body

For bloglinks, use the Solar_App_Bookmarks info in a theme

Need a default node name (WebLog) and suffix (timestamp created).  You
can change the title to anything else, of course.

To get top 10 blog entries ...

	SELECT *
	FROM sc_content_nodes
	WHERE
		current = '1' AND
		node >= 'WebLog_0001-01-01T00:00:00' AND
		node <= 'WebLog_9999-12-31T23:59:59' AND 
		area = :area
	ORDER BY node DESC
	LIMIT (count=10 offset=0)

Could we concatenate the combination of the title, categories, and post body
for the entire node, and then cache that?  it would be faster than to cache
each individual entry and re-get each one every time, right?

Or would it be better to designate an entire area as a blog? Then you get "real" node 
names, not "WebLog_...".


----

Page attachments

sc_file
	id
	name
	title
	descr
	mime
	data

sc_content_file
	id
	area
	node
	nick (nickname for the file as related to this node)
	file_id


----

Searching (only on current)

sc_content_index
	node_id
	word
	times
	
When you save, it converts to plain-text, tokenizes into words ...
Then takes a word-count on each and saves in the content index for the node_id.
