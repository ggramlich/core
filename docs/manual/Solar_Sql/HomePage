Solar_Sql is a facade class for connecting to and querying SQL
databases. It uses PDO-based adapter classes so that you can interact
with MySQL, PostgreSQL, SQLite, Microsoft SQL Server, and so on.

In addition, all Solar_Sql functions are supported on all databases, so
you never need to know the specifics of a particular database backend.
If your Solar_Sql calls work on one database, they should work on all
databases (with some exceptions for how you write your queries; more on
that in the "Portability" section below).

To get started, configure and instantiate a Solar_Sql object using the
available [[Solar_Sql::$_config]] keys.

{{code: php
    // load the Solar environment
    require 'Solar.php';
    Solar::start();

    // configure
    $config = array(
        'adapter' => 'Solar_Sql_Adapter_Mysql',
        'config'  => array(
            'host'   => '127.0.0.1',
            'user'   => 'username',
            'pass'   => 'password',
            'name'   => 'database_name',
        ),
    );

    // instantiate
    $sql = Solar::factory('Solar_Sql', $config);
    }}

    If set up your [[Main::SolarConfig | Solar.config.php file]] like this ...

    {{code: php
    $config = array();
    // ...

    $config['Solar_Sql'] = array(
        'adapter' => 'Solar_Sql_Adapter_Mysql',
        'config'  => array(
            'host'   => '127.0.0.1',
            'user'   => 'username',
            'pass'   => 'password',
            'name'   => 'database_name',
        ),
    );
    // ...
    return $config;
}}

... then Solar_Sql will use those as the default configuration keys.


--------------------
Queries
--------------------

Once you have a Solar_Sql object, you can start issuing queries directly
and getting PDOStatement objects in return:

{{code: php
    $sql = Solar::factory('Solar_Sql');
    $pdoStatement = $sql->query('SELECT * FROM table_name');
}}

Solar_Sql comes with some convenience methods to aid in common query operations:

* [[Solar_Sql::select()]]

* [[Solar_Sql::insert()]]

* [[Solar_Sql::update()]]

* [[Solar_Sql::delete()]]


--------------------
Sequences
--------------------

Solar_Sql encourages the use of sequences, rather than auto-incremented
columns, for reasons of portability and predictability. With sequences,
we construct the entire data set (including IDs) before attempting an
insert or update. Sequences are avaiable for all databases supported by
Solar.

Using sequences is as easy as calling [[Solar_Sql::nextSequence()]] with a
sequence name of your choosing. In general, it's easiest to name the
sequence after a table and column. Whereas with auto-incremented
columns, you would do this ...

{{code: php
    $pdo = new PDO(...);
    $pdo->query("INSERT INTO table_name (id, ...) VALUES (null, ...)";
    $id = $pdo->lastInsertId();
}}

... with sequences, you would do this instead:

{{code: php
    $sql = Solar::factory('Solar_Sql');
    $id = $sql->nextSequence('table_name__id');
    $sql->query("INSERT INTO table_name (id, ...) VALUES ($id, ...)");
}}

The [[Solar_Sql::nextSequence()]] method creates the sequence on-the-fly
and returns the next value for you. You can create and drop sequences on
your own with [[Solar_Sql::createSequence()]] and [[Solar_Sql::dropSequence()]],
respectively.


--------------------
Transactions
--------------------

Solar_Sql begins in auto-commit mode, which means that all queries are
committed to the database as they are executed.

If you want leave auto-commit mode and start a transaction, call
[[Solar_Sql::begin()]]. Then, after you save the transaction using
[[Solar_Sql::commit()]] or cancel it using [[Solar_Sql::rollback()]], Solar_Sql
returns to auto-commit mode until you begin another transaction.


--------------------
Portability
--------------------

Solar_Sql claims to have nearly-automatic database portability. All
Solar_Sql methods should provide identical results regardless of the
database backend. The only exception to this is that not all databases
have the exact same SQL functions and column types available,
particularly with respect to date and time values, as well as LIMIT
offset support.

With that in mind, you should attempt to do the following to ensure the
portability of database work across all supported backends:

1. Use [[Solar_Sql_Select::HomePage | Solar_Sql_Select]] whenever
   possible to construct SELECT statements. This will ensure your LIMIT
   clauses work properly on all databases; some, like Microsoft SQL Server,
   do not support LIMIT offsets, but Solar_Sql_Select has workarounds for
   those systems.

2. Use [[Solar_Sql_Table::HomePage | Solar_Sql_Table]] whenever possible
   to define and create your tables. Solar_Sql_Table creates column
   definitions in a database-portable fashion, so that you can write write
   queries in a standard way. In particular, Solar_Sql_Table uses a
   "poor-man's" abstraction of date and time values by storing them as
   character strings in ISO 8601 format, so that the same date and time
   values in a query will work in any supported database.

3. Try not to use use database-provided SQL functions like YEAR(),
   MONTH(), SUBSTR(), CONCAT(), and so on. If you need these functions, try
   to emulate them at your PHP layer instead of at the database layer.
