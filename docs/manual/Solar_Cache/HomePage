[[toc]]

--------------------
Overview
--------------------

Solar_Cache is a cousin to [PEAR Cache_Lite](http://pear.php.net/Cache_Lite), although most of the options have been made standard behavior.

Solar_Cache is itself a facade class; its methods interface directly with a backend container or adapter class that handles the actual storage or retrieval.

Solar_Cache comes with two adapters, or containers, for cached data:

* the [[Solar_Cache_Adapter_File::HomePage | file adapter]], which stores data in the filesystem

* the [[Solar_Cache_Adapter_Memcache::HomePage | memcache adapter]], which uses [[php::memcache | ]] for storing data in memory

Although the configuration options for the adapters are slightly different, the API for them is identical (because the API is mapped via the master Solar_Cache class).

You can also write your own CustomAdapters if you like.


--------------------
Examples
--------------------

Instantiation
====================

To instantiate Solar_Cache, you need to pick which adapter you want.  In the following example, we'll set up a [[Solar_Cache_Adapter_File::HomePage | file adapter]] cache (which stores data as a file on the hard drive).

{{code: php
    require_once 'Solar.php';
    Solar::start();

    // set up the cache options
    $config = array(
        // which adapter class to use
        'adapter' => 'Solar_Cache_Adapter_File',
        
        // the config options for the class
        'config' => array(
        
            // where the cache files will be stored
            'path' => '/tmp/Solar_Cache/',
            
            // the cache entry lifetime in seconds
            'life' => 1800,
        ),
    );

    // create a cache object
    $cache = Solar::factory('Solar_Cache', $config);
}}

Adapter Configuration
====================

Note that the config keys for the Solar_Cache class are logically separate from the config keys for its adapter classes.  This means you can configure the Solar_Cache, Solar_Cache_Adapter_File, and Solar_Cache_Adapter_Memcache classes separately within the [[Main::ConfigFile | config file]] and Solar will use those options automatically.

For example, you can do this in your config file...

{{code: php
    $config = array();

    // ...

    $config['Solar_Cache_Adapter_File'] => array(
        'path' => '/tmp/Solar_Cache',
        'life' => 1800,
    );

    $config['Solar_Cache'] => array(
        'adapter' => 'Solar_Cache_Adapter_File'
    );

    // ...

    return $config;
}}

... and then instantiate a cache exactly like the above example (because the config file already has the options defined for you) with just one line:

{{code: php
    require_once 'Solar.php';
    Solar::start();

    // create a cache object
    $cache = Solar::factory('Solar_Cache');
}}


Usage
====================

Once you have instantiated the cache, you can use it to store data that usually takes more resources to generate than a filesystem call does (in the case of the [[Solar_Cache_Adapter_File::HomePage | file adapter]]) or a memory call (in the case of the [[Solar_Cache_Adapter_Memcache::HomePage | memcache adapter]]).

In the following example, we simulate caching the results of a database call or other resource-intensive task.  If the cache entry does not exist, we generate the data and save it in the cache; if it does exist, we use that instead (thus speeding up the script execution).

{{code: php
    require_once 'Solar.php';
    Solar::start();

    // connect to the cache
    $cache = Solar::factory('Solar_Cache');

    // every cache entry needs a unique ID; we'll assume that ID
    // is passed as part of the URL.
    $id = Solar::get('id');

    // try to get the cache entry.  if the entry is past its lifetime,
    // this will addiitonally delete the entry for us, keeping the cache
    // clean.
    $output = $cache->fetch($id);

    // did we get it?
    if (! $output) {
        // no output stored in the cache under that ID.
        // regenerate it ...

        // (assume we connect to a database and transform the data in 
        // some way, and call it $output).

        // ... and save the output in the cache, replacing anything that
        // may have been in that entry before.
        $cache->replace($id, $output);
    }

    // now we have the output, whether from the cache
    // or from generating it fresh., we can output it or do whatever
    // else we need.
    echo $output;
}}

--------------------
Limitations and Considerations
--------------------

Because Solar_Cache is intended work exactly the same with every underlying adapter for it, there are some special considerations to take into account.

For example, the PEAR Cache_Lite class allows you to specify "groups" of caches through a single cache object; because the [[Solar_Cache_Adapter_Memcache::HomePage | memcache adapter]] has no way of implementing that kind of function, it is not implemented within the [[Solar_Cache_Adapter_File::HomePage | file adapter]] either.  However, the easy workaround it to have a separate Solar_Cache object for each "group" of caches you want to set up.

If you are on a shared system, you need to make sure the [[Solar_Cache_Adapter_File::HomePage | file adapter]] path is not shared between separate users or installations, otherwise the installations will "compete" with each other when entry keys are identical.  The easy way to work around this is to not to use a system temp directory, and instead set up a directory specifically for caching.