Obviously this is the constructor.  However, it does quite a bit within Solar, particularly when reading the [[Main::ConfigFile | config file]] values for the class.

--------------------
Extending the Constructor
--------------------

When you extend the constructor, make sure the only parameter is "$config = null" (this is how it receives instantiation-time configuration values) and that it calls the parent constructor at some point (with the $config parameter passed up the chain).

For example:

{{code: php
    class Solar_Test_Example extends Solar_Base {
        protected $_config = array(
            'opt_1' => 'foo',
            'opt_2' => 'bar',
            'opt_3' => 'baz'
        );

        public __construct($config = null)
        {
            // pre-parent setup code
            // ...
        
            // parent construction
            parent::__construct($config);
        
            // post-parent setup
            // ...
        }
    }
}}

--------------------
Using The $_config Property
--------------------

When you define a Solar_Base extended class, you will need to populate the Solar_Base::$_config array with all of the options and keys you want the user to be able to configure.  Let's say we want those configuration options to be called "opt_1", "opt_2", and "opt_3" (as a generic example).  You would set up your extended class to define those options as part of the $_config property.

{{code: php
    class Example extends Solar_Base {
        protected $_config = array(
            'opt_1' => 'foo',
            'opt_2' => 'bar',
            'opt_3' => 'baz'
        );
    }
}}

When you use [[Solar::factory()]] to instantiate this class, those will be the default $_config values.

{{code: php
    $example = Solar::factory('Example');
    /*
      The values of $example->_config are as listed above:
  
      'opt_1' => 'foo'
      'opt_2' => 'bar'
      'opt_3' => 'baz'
    */
}}

Config File Settings
====================

Now, if your [[Main::ConfigFile | config file]] has an 'Example' group in it, those values will override any of the default values set by your class definition.  Say your config file looks something like this:

{{code: php
    $config = array();
    // ...
    $config['Example']['opt_3'] = 'dib';
    // ...
    return $config;
}}

When you instantiate the Example object, the config file value will override the default value, leaving all others in place:

{{code: php
    $example = Solar::factory('Example');
    /*
      The values of $example->_config are now:
  
      'opt_1' => 'foo'
      'opt_2' => 'bar'
      'opt_3' => 'dib' ... not 'baz' because it was set in Solar.config.php
    */
}}

Instantiation Settings
====================

Finally, if you specify a configuration array as the second parameter of [[Solar::factory()]], those values override both the default values of the class definition and the Solar.config.php values.

{{code: php
    $config = array('opt_2' => 'gir');
    $example = Solar::factory('Example', $config);
    /*
      The values of $example->_config are now:
  
      'opt_1' => 'foo' ... as defined by the class
      'opt_2' => 'gir' ... from the Solar::factory() instantiation config
      'opt_3' => 'dib' ... from the config file
    */
}}

Order of Precedence
====================

All of this is to say that the order of precedence for $_config property values looks like this:

* The values start as defined by the class,

* And are overwritten by any config file values,

* And are again overwritten by options set at instantiation time

Note that values not changed remain the same, so if you leave one out, it's not overwritten to be null.